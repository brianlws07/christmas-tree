<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas Ai Mei</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }

        #ui-overlay {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #FFD1DC;
            font-family: 'Great Vibes', cursive;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .main-text { font-size: 3.5rem; margin: 0; animation: sparkle 3s infinite ease-in-out; }
        .sub-text { font-size: 2rem; margin: 5px 0 0 20px; font-family: 'Dancing Script', cursive; opacity: 0.9; }

        @keyframes sparkle {
            0%, 100% { filter: brightness(1); text-shadow: 0 0 10px #ff69b4; }
            50% { filter: brightness(1.5); text-shadow: 0 0 25px #fff, 0 0 40px #ff69b4; }
        }

        #hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #FFB7C5; opacity: 0.6; font-family: sans-serif;
            letter-spacing: 3px; text-transform: uppercase; font-size: 10px;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h1 class="main-text">Merry Christmas !!</h1>
        <h2 class="sub-text">Happy New Year Ai Mei !!</h2>
    </div>

    <div id="hint">Click photo to focus â€¢ Click background to expand or converge</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    // --- PHOTO CONFIG ---
    const PHOTO_URLS = ['photo_1.JPG', 'photo_2.JPG', 'photo_3.JPG', 'photo_4.JPG', 'photo_5.JPG', 'photo_6.JPG', 'photo_7.JPG', 'photo_8.JPG'];

    // --- State Variables ---
    let isExpanded = false;
    let focusedPolaroid = null;
    let morphAlpha = 0;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 7, 18); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // High-performance color management
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.0; 
    document.body.appendChild(renderer.domElement);

    // --- Selective Bloom Post-Processing ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.5,  // INCREASE THIS (Strength): Try 1.2 to 2.0 for a stronger glow
    1.0,  // INCREASE THIS (Radius): Try 0.8 to 1.2 to make the light bleed further
    1.0   // KEEP THIS (Threshold): Keep at 1.0 to protect polaroids from blooming
    );
    composer.addPass(bloomPass);
    composer.addPass(new OutputPass());

    const textureLoader = new THREE.TextureLoader();

    // --- Particle Glow Texture ---
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.6)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }
    const glowTex = createGlowTexture();

    // --- Morph Attributes Helper ---
    function setupMorphAttributes(geo, count, positions) {
        const target = new Float32Array(count * 3);
        const offsets = new Float32Array(count);
        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const r = 10 + Math.random() * 10;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            target[i3] = r * Math.sin(phi) * Math.cos(theta);
            target[i3+1] = r * Math.sin(phi) * Math.sin(theta) + 6;
            target[i3+2] = r * Math.cos(phi);
            offsets[i] = Math.random() * 10;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
        geo.setAttribute('basePos', new THREE.BufferAttribute(new Float32Array(positions), 3));
        geo.setAttribute('targetPos', new THREE.BufferAttribute(target, 3));
        geo.setAttribute('floatOffset', new THREE.BufferAttribute(offsets, 1));
    }

    // 1. Tree Body (Increased intensity for bloom)
    const treeGeo = new THREE.BufferGeometry();
    const tPos = [], tCols = [];
    const colorPink = new THREE.Color("#FF69B4").multiplyScalar(2.5); 
    const colorWhite = new THREE.Color(2.5, 2.5, 2.5);

    for (let i = 0; i < 40000; i++) {
        const h = Math.random(), y = h * 12;
        const r = Math.sqrt(Math.random()) * ((1 - h) * 4.6);
        const theta = Math.random() * Math.PI * 2 + (h * Math.PI * 4);
        tPos.push(Math.cos(theta) * r, y, Math.sin(theta) * r);
        
        const c = Math.random() > 0.85 ? colorWhite : colorPink;
        tCols.push(c.r, c.g, c.b);
    }
    setupMorphAttributes(treeGeo, 40000, tPos);
    treeGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(tCols), 3));
    const treePoints = new THREE.Points(treeGeo, new THREE.PointsMaterial({ size: 0.12, map: glowTex, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }));
    scene.add(treePoints);

    // 2. White Spiral
    const spiralGeo = new THREE.BufferGeometry();
    const sPos = [];
    for(let i=0; i<8000; i++) {
        const r = i/8000; const h = r*11.5; const a = r*Math.PI*18; const rad = (1-r)*4.8+0.4;
        sPos.push(Math.cos(a)*rad, h, Math.sin(a)*rad);
    }
    setupMorphAttributes(spiralGeo, 8000, sPos);
    const spiralPoints = new THREE.Points(spiralGeo, new THREE.PointsMaterial({ 
    size: 0.08, 
    color: new THREE.Color(2.5, 2.5, 2.5), // Increase from 1.5 to 2.5
    map: glowTex, 
    transparent: true, 
    blending: THREE.AdditiveBlending 
    }));
    scene.add(spiralPoints);

    // 3. Heart
    const heartGeo = new THREE.BufferGeometry();
    const hPosArr = [];
    for(let i=0; i<1500; i++){
        const t = (i/1500)*Math.PI*2;
        let x = 16*Math.pow(Math.sin(t),3); let y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        hPosArr.push(x*0.04, y*0.04+12.8, 0);
    }
    setupMorphAttributes(heartGeo, 1500, hPosArr);
    const heartPoints = new THREE.Points(heartGeo, new THREE.PointsMaterial({ 
    size: 0.1, 
    color: new THREE.Color(2.5, 2.0, 2.2), // Increase the numbers to make it glow more
    map: glowTex, 
    transparent: true, 
    blending: THREE.AdditiveBlending 
    }));
    scene.add(heartPoints);

    // --- Polaroid Carousel ---
    const polContainer = new THREE.Group();
    scene.add(polContainer);
    const polaroids = [];

    PHOTO_URLS.forEach((url, i) => {
        const group = new THREE.Group();
        // Frame is standard white (1.0), so it won't bloom against threshold 1.0
        const frame = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 2.6), new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
        const photo = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: textureLoader.load(url), side: THREE.DoubleSide }));
        photo.position.z = 0.01;
        group.add(frame, photo);
        group.scale.set(0.35, 0.35, 0.35);

        const angle = (i / PHOTO_URLS.length) * Math.PI * 2;
        const radius = 6.8;
        const y = 3 + (i * 1.6); 
        group.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
        group.lookAt(0, y, 0);
        group.rotateY(Math.PI);

        group.userData = { 
            treePos: group.position.clone(),
            treeRot: group.rotation.clone(),
            floatOffset: Math.random() * 10
        };
        polaroids.push(group);
        polContainer.add(group);
    });

    // --- Interaction ---
    window.addEventListener('mousedown', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(polContainer.children, true);

        if (intersects.length > 0) {
            let obj = intersects[0].object;
            while(obj.parent && !polaroids.includes(obj)) { obj = obj.parent; }
            focusedPolaroid = (focusedPolaroid === obj) ? null : obj;
        } else {
            // Background click toggles expand/converge
            if (focusedPolaroid) focusedPolaroid = null;
            else isExpanded = !isExpanded;
        }
    });

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function updateSystem(pointsObj, alpha, time) {
        const geo = pointsObj.geometry;
        const pos = geo.attributes.position.array;
        const base = geo.attributes.basePos.array;
        const target = geo.attributes.targetPos.array;
        const offset = geo.attributes.floatOffset.array;

        for (let i = 0; i < geo.attributes.position.count; i++) {
            const i3 = i * 3;
            let x = THREE.MathUtils.lerp(base[i3], target[i3], alpha);
            let y = THREE.MathUtils.lerp(base[i3+1], target[i3+1], alpha);
            let z = THREE.MathUtils.lerp(base[i3+2], target[i3+2], alpha);

            // Stardust float drift
            x += Math.sin(time * 0.4 + offset[i]) * 0.3 * alpha;
            y += Math.cos(time * 0.3 + offset[i]) * 0.3 * alpha;

            pos[i3] = x; pos[i3+1] = y; pos[i3+2] = z;
        }
        geo.attributes.position.needsUpdate = true;
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // Smooth transition alpha
        morphAlpha = THREE.MathUtils.lerp(morphAlpha, isExpanded ? 1 : 0, 0.04);

        // Update all particle systems
        updateSystem(treePoints, morphAlpha, time);
        updateSystem(spiralPoints, morphAlpha, time);
        updateSystem(heartPoints, morphAlpha, time);

        // Carousel Logic
        if (!focusedPolaroid) {
            polContainer.rotation.y += 0.005;
        }

        polaroids.forEach(p => {
            const d = p.userData;
            if (focusedPolaroid === p) {
                // Focus: Move to center front in world space
                const localFocusPos = new THREE.Vector3(0, 0, 11).applyQuaternion(polContainer.quaternion.clone().invert());
                localFocusPos.y = 7; 
                p.position.lerp(localFocusPos, 0.1);
                
                // Rotation alignment to camera
                const targetRot = new THREE.Euler(0, -polContainer.rotation.y, 0);
                p.quaternion.slerp(new THREE.Quaternion().setFromEuler(targetRot), 0.1);
                p.scale.lerp(new THREE.Vector3(1.3, 1.3, 1.3), 0.1);
            } else {
                // Shell Position
                p.position.lerp(d.treePos, 0.05);
                p.quaternion.slerp(new THREE.Quaternion().setFromEuler(d.treeRot), 0.05);
                p.scale.lerp(new THREE.Vector3(0.35, 0.35, 0.35), 0.1);
                
                // Ornament float
                p.position.y += Math.sin(time + d.floatOffset) * 0.005;
            }
        });

        if (!isExpanded) {
            treePoints.rotation.y += 0.001;
            spiralPoints.rotation.y += 0.0015;
        }

        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>